from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel
from typing import List, Optional
from pymongo import MongoClient
from bson import ObjectId
import os
from datetime import datetime

# Initialize FastAPI app
app = FastAPI(title="Ecommerce API", description="FastAPI backend for ecommerce application")

# MongoDB connection
MONGO_URL = os.getenv("MONGO_URL", "mongodb://localhost:27017")
client = MongoClient(MONGO_URL)
db = client.ecommerce
products_collection = db.products
orders_collection = db.orders

# Pydantic models
class SizeQuantity(BaseModel):
    size: str
    quantity: int

class ProductCreate(BaseModel):
    name: str
    price: float
    sizes: List[SizeQuantity]

class ProductResponse(BaseModel):
    id: str
    name: str
    price: float
    sizes: List[SizeQuantity] = []

class OrderItem(BaseModel):
    product_id: str
    qty: int

class OrderCreate(BaseModel):
    user_id: str
    items: List[OrderItem]

class OrderResponse(BaseModel):
    id: str

class OrderDetail(BaseModel):
    id: str
    items: List[dict]
    total: float

# Utility functions
def product_helper(product) -> dict:
    return {
        "id": str(product["_id"]),
        "name": product["name"],
        "price": product["price"],
        "sizes": product.get("sizes", [])
    }

def order_helper(order) -> dict:
    return {
        "id": str(order["_id"]),
        "user_id": order["user_id"],
        "items": order["items"],
        "total": order["total"],
        "created_at": order.get("created_at")
    }

# API Endpoints

@app.post("/products", response_model=dict, status_code=201)
async def create_product(product: ProductCreate):
    """
    Create a new product with name, price, and sizes
    """
    try:
        product_dict = {
            "name": product.name,
            "price": product.price,
            "sizes": [{"size": size.size, "quantity": size.quantity} for size in product.sizes],
            "created_at": datetime.utcnow()
        }
        
        result = products_collection.insert_one(product_dict)
        
        return {"id": str(result.inserted_id)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/products", response_model=dict, status_code=200)
async def list_products(
    name: Optional[str] = Query(None, description="Filter by product name (supports partial search)"),
    size: Optional[str] = Query(None, description="Filter by size (e.g., 'large')"),
    limit: Optional[int] = Query(10, description="Number of products to return"),
    offset: Optional[int] = Query(0, description="Number of products to skip")
):
    """
    List products with optional filtering by name and size, with pagination
    """
    try:
        # Build query
        query = {}
        
        if name:
            query["name"] = {"$regex": name, "$options": "i"}  # Case-insensitive partial search
        
        if size:
            query["sizes.size"] = size
        
        # Get total count for pagination
        total_count = products_collection.count_documents(query)
        
        # Fetch products with pagination
        cursor = products_collection.find(query).skip(offset).limit(limit).sort("_id", 1)
        products = []
        
        for product in cursor:
            product_data = {
                "id": str(product["_id"]),
                "name": product["name"],
                "price": product["price"]
                # Note: sizes not included in output as per the example response
            }
            products.append(product_data)
        
        # Calculate pagination info
        next_offset = offset + limit if offset + limit < total_count else None
        previous_offset = max(0, offset - limit) if offset > 0 else None
        
        return {
            "data": products,
            "page": {
                "next": str(next_offset) if next_offset is not None else None,
                "limit": limit,
                "previous": str(previous_offset) if previous_offset is not None else None
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/orders", response_model=dict, status_code=201)
async def create_order(order: OrderCreate):
    """
    Create a new order with user_id and list of items
    """
    try:
        # Validate products exist and calculate total
        total = 0.0
        validated_items = []
        
        for item in order.items:
            # Check if product exists
            product = products_collection.find_one({"_id": ObjectId(item.product_id)})
            if not product:
                raise HTTPException(status_code=404, detail=f"Product {item.product_id} not found")
            
            item_total = product["price"] * item.qty
            total += item_total
            
            validated_items.append({
                "product_id": item.product_id,
                "qty": item.qty,
                "price": product["price"],
                "item_total": item_total
            })
        
        order_dict = {
            "user_id": order.user_id,
            "items": validated_items,
            "total": total,
            "created_at": datetime.utcnow()
        }
        
        result = orders_collection.insert_one(order_dict)
        
        return {"id": str(result.inserted_id)}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/orders/{user_id}", response_model=dict, status_code=200)
async def get_user_orders(
    user_id: str,
    limit: Optional[int] = Query(10, description="Number of orders to return"),
    offset: Optional[int] = Query(0, description="Number of orders to skip")
):
    """
    Get list of orders for a specific user with pagination
    """
    try:
        query = {"user_id": user_id}
        
        # Get total count
        total_count = orders_collection.count_documents(query)
        
        # Fetch orders with pagination
        cursor = orders_collection.find(query).skip(offset).limit(limit).sort("_id", -1)
        orders = []
        
        for order in cursor:
            # Get product details for each item
            items_with_products = []
            for item in order["items"]:
                product = products_collection.find_one({"_id": ObjectId(item["product_id"])})
                if product:
                    items_with_products.append({
                        "product_id": item["product_id"],
                        "name": product["name"],
                        "qty": item["qty"]
                    })
            
            order_data = {
                "id": str(order["_id"]),
                "items": items_with_products,
                "qty": sum(item["qty"] for item in order["items"])
            }
            orders.append(order_data)
        
        # Calculate pagination info
        next_offset = offset + limit if offset + limit < total_count else None
        previous_offset = max(0, offset - limit) if offset > 0 else None
        
        return {
            "data": orders,
            "page": {
                "next": str(next_offset) if next_offset is not None else None,
                "limit": limit,
                "previous": str(previous_offset) if previous_offset is not None else None
            },
            "total": total_count
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Health check endpoint
@app.get("/")
async def root():
    return {"message": "Ecommerce API is running"}

@app.get("/health")
async def health_check():
    try:
        # Test MongoDB connection
        db.command('ping')
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Database connection failed: {str(e)}")

# Run the application
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
